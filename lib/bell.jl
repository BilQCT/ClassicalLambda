"""
# Computing expectations #

In the code below we will compute the expectations given the input:  X  a simplicial set, a natural number  d ,  G  a group and  ρ  a quantum state. The idea is as follows:
1. We firstly compute the commutative fundamental group  π := π₁(Z_d,X) .
2. Then the group homomorphisms  π to G  are in one-to-one correspondence with simplicial set maps  X to N(Z_d,G) . However, for computing group homomorphisms we can use GAP.
3. Using GAP, we find irreducible unitary representations of  G .
4. We compute the composite mappings   π to G to U , where  U  is a group of unitaries.
5. Finally, we compute the traces of products of unitaries assigned to edges and   ρ .

Let's go!
"""

using GAP 
const g =GAP.Globals
using LinearAlgebra


#Compute the commutative fundamental group of the space
comm_group = function(simp,d)
    """
    Compute the commutative fundamental group of the space.

    Parameters:
        - simp: Tuple: simplicial set
        - d: Int: Natural number

    Returns:
        - GAP.FpGroup: Commutative fundamental group of the space
    """
    Relations = []
    F = g.FreeGroup(length(simp[2]))
    gens = g.GeneratorsOfGroup(F)
    #The code below will assign a relation for every 2-simplex
    for s in simp[3]
            rel1 = gens[s[2][1]]*gens[s[2][3]]*gens[s[2][2]]^(-1)
            push!(Relations,rel1)
            rel2 = gens[s[2][1]]*gens[s[2][2]]*gens[s[2][1]]^(-1)*gens[s[2][2]]^(-1)
            push!(Relations,rel2)
            rel3 = gens[s[2][1]]*gens[s[2][3]]*gens[s[2][1]]^(-1)*gens[s[2][3]]^(-1)
            push!(Relations,rel3)
            rel4 = gens[s[2][2]]*gens[s[2][3]]*gens[s[2][2]]^(-1)*gens[s[2][3]]^(-1)
            push!(Relations,rel4)
                end
    #Now we add d-torsion relations
    for s in simp[2]
           rel = gens[s[1]]^d
           push!(Relations,rel)
    end
    Gr = F/GapObj(Relations)
    return Gr
end



#Simplified group
simplified = function(group)
    """
    Simplify a group.

    Parameters:
        - group: GAP.FpGroup: Group to be simplified

    Returns:
        - GAP.FpGroup: Simplified group
    """
    return g.IsomorphismSimplifiedFpGroup(group)
end




#Looking for homomorphisms
homomorphisms = function(group1, group2)
    """
    Look for homomorphisms between two groups.

    Parameters:
        - group1: GAP.FpGroup: First group
        - group2: GAP.FpGroup: Second group

    Returns:
        - Array{GAP.Homomorphism}: Array of homomorphisms between the two groups
    """
    gens1 = g.GeneratorsOfGroup(group1)
    elsG = g.Elements(group2);
    homs = []
    C = g.Tuples(elsG,length(gens1))
    for i in 1:length(C)
      H = g.GroupHomomorphismByImages(group1,group2,gens1,C[i])
    if H != g.fail push!(homs,H) end
    end
    return homs 
end



# input: integer d for Zd
# output: dictionary object that maps string(group element) to integer in {0,...,d-1}
# assumes: two generators (id, f1) such that elements can be generated by f1^n. (d = prime)
function cyclic_group_to_integers(d)
    """
    Convert a cyclic group to integers.

    Parameters:
        - d: Int: Integer for Zd

    Returns:
        - Dict: Dictionary mapping string(group element) to integer in {0,...,d-1}
    """
    if g.IsPrimeInt(d) == false
        return "Must be a prime integer."
    else
        G = g.SmallGroup(d,1);
        return Dict(zip([string(g.Elements(G)[j]) for j in 1:length(g.Elements(G))],[(i-1) for i in 1:d]))
    end
end




# input: simplicial set X and integer d for Zd
# output: assignment of values {0,...,d-1} to edges compatible with simplicial structure
function outcome_maps(X,d)
    """
    Compute outcome maps.

    Parameters:
        - X: Tuple: Simplicial set
        - d: Int: Integer for Zd

    Returns:
        - Union{Dict, Array}: Assignment of values {0,...,d-1} to edges compatible with simplicial structure
    """
    G = g.SmallGroup(d,1); Pi = comm_group(X,d); gens = g.GeneratorsOfGroup(Pi);
    dict = cyclic_group_to_integers(d); assignments = [];

    if typeof(dict) == String
        return dict
    
    else
        # Compute homomorphisms:
        homs = homomorphisms(Pi,G);
        N = length(homs);
        for i in 1:N
            homomorphism = homs[i];
            
            assignment = [dict[string(g.Image(homomorphism,gens[j]))] for j in 1:length(gens)];
            push!(assignments,assignment);

        end

        return assignments
    end
end




# input: two-dimensional simplicial set X. d is fixed to 2.
# output: array of deterministic vertices in edge coordinates.
function deterministic_vertices(X)
    """
    Compute deterministic vertices in edge coordinates.

    Parameters:
        - X: Tuple: Two-dimensional simplicial set

    Returns:
        - Array{Int64}: Array of deterministic vertices in edge coordinates
    """
    outcomes = outcome_maps(X,2); L = length(outcomes[1]); N = length(outcomes);
    vertices = Array{Int64}(undef, 0, L); col = ones(Int8,N);
    for i in 1:N
        o = outcomes[i]; vertex = [(-1)^o[j] for j in 1:L];
        vertices = vcat(vertices,transpose(vertex));
    end
    return hcat(col,vertices)
end


using Polymake
const pm = Polymake

function Bell_polytope(X)
    """
    Compute Bell polytope using EDGE representation.

    Parameters:
        - X: Tuple: Two-dimensional simplicial set

    Returns:
        - pm.polytope.Polytope: Bell polytope
    """
    vertices = deterministic_vertices_EDGE(X);
    return pm.polytope.Polytope(POINTS = vertices)
end
